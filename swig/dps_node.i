%module(docstring="Distributed Publish Subscribe for IoT") dps
%feature("autodoc", "1");

%{
#include <dps/dps.h>
#include <dps/dbg.h>
#include <dps/err.h>
#include <condition_variable>
#include <mutex>
#include <queue>
#include "dps.hh"
%}

%include "cdata.i"
%include "constraints.i"
%include "typemaps.i"

/*
 * Ignore this warning generated by the nested union inside DPS_Key.
 * Suppressing it with warnfilter doesn't appear to work.
 */
#pragma SWIG nowarn=312

/*
 * Functions that must not be exposed
 */
%ignore DPS_DestroyKeyStore;
%ignore DPS_DestroyNode;
%ignore DPS_DestroyPublication;
%ignore DPS_DestroySubscription;
%ignore DPS_GetKeyStoreData;
%ignore DPS_GetLoop;
%ignore DPS_GetPublicationData;
%ignore DPS_GetSubscriptionData;
%ignore DPS_KeyStoreHandle;
%ignore DPS_MemoryKeyStoreHandle;
%ignore DPS_PublicationGetNumTopics;
%ignore DPS_PublicationGetTopic;
%ignore DPS_SetKeyStoreData;
%ignore DPS_SetPublicationData;
%ignore DPS_SetSubscriptionData;
%ignore DPS_SubscriptionGetNumTopics;
%ignore DPS_SubscriptionGetTopic;
%ignore _DPS_Key;
%ignore _DPS_KeyCert;
%ignore _DPS_KeyEC;
%ignore _DPS_KeyId;
%ignore _DPS_KeySymmetric;

/*
 * Declarations that are not relevant in JavaScript
 */
%ignore DPS_TRUE;
%ignore DPS_FALSE;

/*
 * Module is called dps we don't need the DPS prefix on every function
 */
%rename("debug") DPS_Debug;
%rename("%(regex:/DPS_(.*)/\\l\\1/)s", %$isfunction) "";
%rename("%(strip:[DPS_])s", %$not %$isfunction) "";

/*
 * Mapping for types from stdint.h
 */
%typemap(in) uint8_t* = char*;
%typemap(in) int16_t = int;
%typemap(out) int16_t = int;
%typemap(in) uint16_t = unsigned int;
%typemap(out) uint16_t = unsigned int;
%typemap(in) uint32_t = unsigned long;
%typemap(out) uint32_t = unsigned long;

/*
 * Allow JavaScript true, false for DPS boolean (int)
 */
%typemap(in) int {
    int b = 0;

    if ($input->IsBoolean()) {
        b = $input->BooleanValue() ? 1 : 0;
    } else {
        int ecode = SWIG_AsVal_int($input, &b);
        if (!SWIG_IsOK(ecode)) {
            SWIG_exception_fail(SWIG_ArgError(ecode), "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
        }
    }

    $1 = b;
}

/*
 * This allows topic strings to be expressed as a list of strings
 */
%typemap(in) (const char** topics, size_t numTopics) {
    /* Expecting a list of strings */
    if ($input->IsArray()) {
        v8::Local<v8::Array> arr = v8::Local<v8::Array>::Cast($input);
        uint32_t n = arr->Length();
        $1 = (char**)calloc(n + 1, sizeof(char*));
        uint32_t i;
        for (i = 0; i < n; ++i) {
            v8::Local<v8::Value> valRef;
            if (arr->Get(SWIGV8_CURRENT_CONTEXT(), i).ToLocal(&valRef)) {
                v8::Local<v8::String> str = v8::Local<v8::String>::Cast(valRef);
                $1[i] = (char*)malloc(str->Utf8Length() + 1);
                str->WriteUtf8($1[i]);
            } else {
                for (uint32_t j = 0; j < i; ++j)
                    free($1[j]);
                free($1);
                SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
            }
        }
        $1[i] = NULL;
        $2 = arr->Length();
    } else {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
}

/*
 * Post function call cleanup for topic strings
 */
%typemap(freearg) (const char** topics, size_t numTopics) {
    /* Freeing a list of strings */
    for (uint32_t i = 0; i < $2; ++i)
        free($1[i]);
    free($1);
}

%typemap(in,numinputs=0,noblock=1) size_t* n {
  size_t sz;
  $1 = &sz;
}

%typemap(out) const char** subscriptionGetTopics {
    $result = v8::Array::New(v8::Isolate::GetCurrent(), sz);
    for (size_t i = 0; i < sz; ++i) {
        v8::Local<v8::Array>::Cast($result)->Set(i, SWIG_FromCharPtr($1[i]));
    }
    free($1);
}

%inline %{
const char** subscriptionGetTopics(const DPS_Subscription* sub, size_t* n)
{
    *n = DPS_SubscriptionGetNumTopics(sub);
    const char** topics = (const char**)calloc(*n, sizeof(const char *));
    for (size_t i = 0; i < *n; ++i) {
        topics[i] = DPS_SubscriptionGetTopic(sub, i);
    }
    return topics;
}
%}

%typemap(out) const char** publicationGetTopics {
    $result = v8::Array::New(v8::Isolate::GetCurrent(), sz);
    for (size_t i = 0; i < sz; ++i) {
        v8::Local<v8::Array>::Cast($result)->Set(i, SWIG_FromCharPtr($1[i]));
    }
    free($1);
}

%inline %{
const char** publicationGetTopics(const DPS_Publication* pub, size_t* n)
{
    *n = DPS_PublicationGetNumTopics(pub);
    const char** topics = (const char**)calloc(*n, sizeof(const char *));
    for (size_t i = 0; i < *n; ++i) {
        topics[i] = DPS_PublicationGetTopic(pub, i);
    }
    return topics;
}
%}

/*
 * For now just allow strings as payloads.
 * Eventually need to figure out how to handle binary data.
 */
%{
static uint8_t* AllocPayload(v8::Local<v8::Value> valRef, size_t* len)
{
    uint8_t* payload = NULL;
    if (valRef->IsString()) {
        v8::Local<v8::String> str = v8::Local<v8::String>::Cast(valRef);
        uint32_t sz = str->Utf8Length();
        payload = (uint8_t*)malloc(sz + 1);
        str->WriteUtf8((char*)payload);
        *len = (size_t)sz;
    }
    return payload;
}
%}

%typemap(in) (const uint8_t* pubPayload, size_t len), (const uint8_t* ackPayload, size_t len) {
    $1 = AllocPayload($input, &$2);
    if (!$1) {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
}

%typemap(freearg) (const uint8_t* pubPayload, size_t len), (const uint8_t* ackPayload, size_t len) {
    free($1);
}

%typemap(in) (const DPS_KeyId* keyId) {
    DPS_KeyId* kid = NULL;

    v8::Handle<v8::Value> obj($input);

    if (obj->IsUint8Array() || obj->IsArray() || obj->IsString()) {
        kid = (DPS_KeyId*)malloc(sizeof(DPS_KeyId));
        if (!kid) {
            SWIG_exception_fail(SWIG_ERROR, "no memory");
        }
        if (!SWIG_IsOK(UnwrapBytes(obj, (uint8_t**)&kid->id, &kid->len))) {
            free(kid);
            SWIG_exception_fail(SWIG_ERROR, "no memory");
        }
    } else if (!obj->IsNull()) {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }

    $1 = kid;
}

%typemap(freearg) (const DPS_KeyId* keyId) {
    if ($1) {
        if ($1->id) {
            free((uint8_t*)$1->id);
        }
        free($1);
    }
}

%{
static v8::Handle<v8::Array> WrapBytes(const uint8_t* bytes, size_t len)
{
    v8::Handle<v8::Array> arr = SWIGV8_ARRAY_NEW();
    for (size_t i = 0; i < len; ++i) {
        arr->Set(i, SWIGV8_INTEGER_NEW_UNS(bytes[i]));
    }
    return arr;
}

static int UnwrapBytes(v8::Handle<v8::Value> obj, uint8_t** bytes, size_t* len)
{
    (*len) = 0;
    (*bytes) = NULL;
    if (obj->IsUint8Array()) {
        v8::Local<v8::ArrayBuffer> buf;
        v8::Local<v8::Uint8Array> arr = v8::Local<v8::Uint8Array>::Cast(obj);
        (*len) = arr->ByteLength();
        (*bytes) = (uint8_t*)malloc((*len));
        if (!(*bytes)) {
            return SWIG_MemoryError;
        }
        size_t off = arr->ByteOffset();
        uint8_t* data = (uint8_t*)arr->Buffer()->GetContents().Data();
        memcpy((*bytes), &data[off], (*len));
    } else if (obj->IsArray()) {
        v8::Local<v8::Array> arr = v8::Local<v8::Array>::Cast(obj);
        (*len) = arr->Length();
        (*bytes) = (uint8_t*)malloc((*len));
        if (!(*bytes)) {
            return SWIG_MemoryError;
        }
        size_t i;
        for (i = 0; i < (*len); ++i) {
            v8::Local<v8::Value> valRef;
            if (arr->Get(SWIGV8_CURRENT_CONTEXT(), i).ToLocal(&valRef)) {
                (*bytes)[i] = valRef->Uint32Value();
            } else {
                free((*bytes));
                return SWIG_TypeError;
            }
        }
    } else if (obj->IsString()) {
        v8::Local<v8::String> str = v8::Local<v8::String>::Cast(obj);
        (*len) =str->Utf8Length();
        (*bytes) = (uint8_t*)malloc((*len) + 1);
        if (!(*bytes)) {
            return SWIG_MemoryError;
        }
        str->WriteUtf8((char*)(*bytes));
    } else if (!obj->IsNull()) {
        return SWIG_TypeError;
    }
    return SWIG_OK;
}

static void FreeBytes(uint8_t* bytes) {
    if (bytes) {
        free(bytes);
    }
}
%}

%typemap(in) (const uint8_t* key, size_t len) {
    if (!SWIG_IsOK(UnwrapBytes($input, &$1, &$2))) {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
}
%typemap(in) (const uint8_t* x), (const uint8_t* y), (const uint8_t* d) {
    size_t unused;
    if (!SWIG_IsOK(UnwrapBytes($input, &$1, &unused))) {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
}

%typemap(freearg) (const uint8_t* key, size_t len),
                  (const uint8_t* x), (const uint8_t* y), (const uint8_t* d) {
    FreeBytes($1);
}

/*
 * Type maps for default arguments
 * These appear to not be implemented in JavaScript
 */

/*
 * Callback support
 */
%{
class Callback {
public:
    std::condition_variable* m_cond;
    Callback() : m_cond(NULL) { }
    virtual ~Callback() { }
    virtual void Call() = 0;
};

static std::mutex mutex;
static std::queue<Callback*> queue;
static uv_thread_t node_thread;
static uv_async_t async;

static void async_cb(uv_async_t* handle)
{
    SWIGV8_HANDLESCOPE();

    mutex.lock();
    while (!queue.empty()) {
        Callback* cb = queue.front();
        queue.pop();
        mutex.unlock();
        cb->Call();
        if (cb->m_cond) {
            cb->m_cond->notify_one();
        }
        delete cb;
        mutex.lock();
    }
    mutex.unlock();
}

static void async_send(Callback* cb)
{
    std::unique_lock<std::mutex> lock(mutex);
    queue.push(cb);
    uv_async_send(&async);
}

static void sync_send(Callback* cb)
{
    uv_thread_t self = uv_thread_self();
    if (uv_thread_equal(&node_thread, &self)) {
        cb->Call();
        delete cb;
    } else {
        std::condition_variable cond;
        std::unique_lock<std::mutex> lock(mutex);
        cb->m_cond = &cond;
        queue.push(cb);
        uv_async_send(&async);
        cond.wait(lock);
    }
}
%}

/*
 * The destroy node callback is not needed
 */
%{
DPS_Status destroyNode(DPS_Node* node)
{
    return DPS_DestroyNode(node, NULL, NULL);
}
%}

DPS_Status destroyNode(DPS_Node* node);

%{
struct Function {
    v8::Persistent<v8::Function> fn;
};
%}

/*
 * Publication acknowledgment function calls into JavaScript
 */
%{
class AckCallback : public Callback {
public:
    const DPS_Publication* m_pub;
    uint8_t* m_payload;
    size_t m_len;
    AckCallback(DPS_Publication* pub, uint8_t* payload, size_t len) {
        m_pub = pub;
        m_payload = new uint8_t[len+1];
        memcpy(m_payload, payload, len);
        payload[len+1] = 0;
        m_len = len;
    }
    virtual ~AckCallback() {
        delete[] m_payload;
    }
    void Call() {
        Function* function = (Function*)DPS_GetPublicationData(m_pub);
        v8::Local<v8::Function> fn = v8::Local<v8::Function>::New(v8::Isolate::GetCurrent(), function->fn);
        int argc = 2;
        v8::Local<v8::Value> argv[argc];
        argv[0] = SWIG_NewPointerObj(SWIG_as_voidptr(m_pub), SWIGTYPE_p__DPS_Publication, 0);
        argv[1] = SWIGV8_STRING_NEW2((const char*)m_payload, m_len); /* For now just allow strings as payloads */
        (void)fn->Call(SWIGV8_CURRENT_CONTEXT(), SWIGV8_CURRENT_CONTEXT()->Global(),
                       argc, argv);
    }
    static void Handler(DPS_Publication* pub, uint8_t* payload, size_t len) {
        async_send(new AckCallback(pub, payload, len));
    }
};
%}

/*
 * Acknowledgement callback wrapper
 */
%typemap(in) DPS_AcknowledgementHandler {
    if (!$input->IsFunction()) {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
    if (arg1) {
        v8::Local<v8::Function> fn = v8::Local<v8::Function>::Cast($input);
        Function* function = new Function();
        function->fn.Reset(v8::Isolate::GetCurrent(), fn);
        DPS_Status ret = DPS_SetPublicationData(arg1, function);
        if (ret != DPS_OK) {
            SWIG_exception_fail(SWIG_ERROR, "unable to set callback");
        }
        $1 = AckCallback::Handler;
    }
}

%{
DPS_Status destroyPublication(DPS_Publication* pub)
{
    Function* function = (Function*)DPS_GetPublicationData(pub);
    delete function;
    return DPS_DestroyPublication(pub);
}
%}

DPS_Status destroyPublication(DPS_Publication* pub);

/*
 * Publication received function calls into JavaScript
 */
%{
class PubCallback : public Callback {
public:
    DPS_Subscription* m_sub;
    DPS_Publication* m_pub;
    uint8_t* m_payload;
    size_t m_len;
    PubCallback(DPS_Subscription* sub, const DPS_Publication* pub, uint8_t* payload, size_t len) {
        m_sub = sub;
        m_pub = DPS_CopyPublication(pub);
        m_payload = new uint8_t[len+1];
        memcpy(m_payload, payload, len);
        payload[len+1] = 0;
        m_len = len;
    }
    virtual ~PubCallback() {
        DPS_DestroyPublication(m_pub);
        delete[] m_payload;
    }
    void Call() {
        Function* function = (Function*)DPS_GetSubscriptionData(m_sub);
        v8::Local<v8::Function> fn = v8::Local<v8::Function>::New(v8::Isolate::GetCurrent(), function->fn);
        int argc = 3;
        v8::Local<v8::Value> argv[argc];
        argv[0] = SWIG_NewPointerObj(SWIG_as_voidptr(m_sub), SWIGTYPE_p__DPS_Subscription, 0);
        argv[1] = SWIG_NewPointerObj(SWIG_as_voidptr(m_pub), SWIGTYPE_p__DPS_Publication, 0);
        argv[2] = SWIGV8_STRING_NEW2((const char*)m_payload, m_len); /* For now just allow strings as payloads */
        (void)fn->Call(SWIGV8_CURRENT_CONTEXT(), SWIGV8_CURRENT_CONTEXT()->Global(),
                       argc, argv);
    }
    static void Handler(DPS_Subscription* sub, const DPS_Publication* pub, uint8_t* payload, size_t len) {
        async_send(new PubCallback(sub, pub, payload, len));
    }
};
%}

/*
 * Publication callback wrapper
 */
%typemap(in) DPS_PublicationHandler {
    if (!$input->IsFunction()) {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
    if (arg1) {
        v8::Local<v8::Function> fn = v8::Local<v8::Function>::Cast($input);
        Function* function = new Function();
        function->fn.Reset(v8::Isolate::GetCurrent(), fn);
        DPS_Status ret = DPS_SetSubscriptionData(arg1, function);
        if (ret != DPS_OK) {
            SWIG_exception_fail(SWIG_ERROR, "unable to set callback");
        }
        $1 = PubCallback::Handler;
    }
}

%{
DPS_Status destroySubscription(DPS_Subscription* sub)
{
    Function* function = (Function*)DPS_GetSubscriptionData(sub);
    delete function;
    return DPS_DestroySubscription(sub);
}
%}

DPS_Status destroySubscription(DPS_Subscription* sub);

/*
 * Key function calls into JavaScript
 */
%{
struct KeyStoreFunctions {
    v8::Persistent<v8::Function> keyAndId;
    v8::Persistent<v8::Function> key;
    v8::Persistent<v8::Function> ephemeralKey;
    v8::Persistent<v8::Function> ca;
};

class KeyAndIdCallback : public Callback {
public:
    DPS_KeyStoreRequest* m_request;
    DPS_Status* m_ret;
    KeyAndIdCallback(DPS_KeyStoreRequest* request, DPS_Status* ret)
         : m_request(request), m_ret(ret) { }
    void Call() {
        DPS_KeyStore* keyStore = DPS_KeyStoreHandle(m_request);
        KeyStoreFunctions* functions = (KeyStoreFunctions*)DPS_GetKeyStoreData(keyStore);
        v8::Local<v8::Function> fn = v8::Local<v8::Function>::New(v8::Isolate::GetCurrent(), functions->keyAndId);
        int argc = 1;
        v8::Local<v8::Value> argv[argc];
        argv[0] = SWIG_NewPointerObj(SWIG_as_voidptr(m_request), SWIGTYPE_p__DPS_KeyStoreRequest, 0);
        v8::MaybeLocal<v8::Value> ret = fn->Call(SWIGV8_CURRENT_CONTEXT(), SWIGV8_CURRENT_CONTEXT()->Global(),
                                                 argc, argv);
        int result = DPS_ERR_MISSING;
        if (!ret.IsEmpty()) {
            result = ret.ToLocalChecked()->IntegerValue();
        }
        *m_ret = result;
    }
    static DPS_Status Handler(DPS_KeyStoreRequest* request) {
        DPS_Status ret;
        sync_send(new KeyAndIdCallback(request, &ret));
        return ret;
    }
};

class KeyCallback : public Callback {
public:
    DPS_KeyStoreRequest* m_request;
    const DPS_KeyId* m_keyId;
    DPS_Status* m_ret;
    KeyCallback(DPS_KeyStoreRequest* request, const DPS_KeyId* keyId, DPS_Status* ret)
        : m_request(request), m_keyId(keyId), m_ret(ret) { }
    void Call() {
        DPS_KeyStore* keyStore = DPS_KeyStoreHandle(m_request);
        KeyStoreFunctions* functions = (KeyStoreFunctions*)DPS_GetKeyStoreData(keyStore);
        v8::Local<v8::Function> fn = v8::Local<v8::Function>::New(v8::Isolate::GetCurrent(), functions->key);
        int argc = 2;
        v8::Local<v8::Value> argv[argc];
        argv[0] = SWIG_NewPointerObj(SWIG_as_voidptr(m_request), SWIGTYPE_p__DPS_KeyStoreRequest, 0);
        if (m_keyId) {
            argv[1] = WrapBytes(m_keyId->id, m_keyId->len);
        } else {
            argv[1] = WrapBytes(NULL, 0);
        }
        v8::MaybeLocal<v8::Value> ret = fn->Call(SWIGV8_CURRENT_CONTEXT(), SWIGV8_CURRENT_CONTEXT()->Global(),
                                                 argc, argv);
        int result = DPS_ERR_MISSING;
        if (!ret.IsEmpty()) {
            result = ret.ToLocalChecked()->IntegerValue();
        }
        *m_ret = result;
    }
    static DPS_Status Handler(DPS_KeyStoreRequest* request, const DPS_KeyId* keyId) {
        DPS_Status ret;
        sync_send(new KeyCallback(request, keyId, &ret));
        return ret;
    }
};

class EphemeralKeyCallback : public Callback {
public:
    DPS_KeyStoreRequest* m_request;
    const dps::Key* m_key;
    DPS_Status* m_ret;
    EphemeralKeyCallback(DPS_KeyStoreRequest* request, const DPS_Key* key, DPS_Status* ret)
        : m_request(request), m_ret(ret) {
        switch (key->type) {
        case DPS_KEY_SYMMETRIC:
            m_key = new dps::SymmetricKey(key->symmetric.key, key->symmetric.len);
            break;
        case DPS_KEY_EC:
            m_key = new dps::ECKey(key->ec.curve, key->ec.x, key->ec.y, key->ec.d);
            break;
        case DPS_KEY_EC_CERT:
            m_key = new dps::CertKey(key->cert.cert, key->cert.privateKey, key->cert.password);
            break;
        }
    }
    ~EphemeralKeyCallback() {
        delete m_key;
    }
    void Call() {
        DPS_KeyStore* keyStore = DPS_KeyStoreHandle(m_request);
        KeyStoreFunctions* functions = (KeyStoreFunctions*)DPS_GetKeyStoreData(keyStore);
        v8::Local<v8::Function> fn = v8::Local<v8::Function>::New(v8::Isolate::GetCurrent(), functions->ephemeralKey);
        int argc = 2;
        v8::Local<v8::Value> argv[argc];
        argv[0] = SWIG_NewPointerObj(SWIG_as_voidptr(m_request), SWIGTYPE_p__DPS_KeyStoreRequest, 0);
        switch (m_key->type) {
        case DPS_KEY_SYMMETRIC:
            argv[1] = SWIG_NewPointerObj(SWIG_as_voidptr(m_key), SWIGTYPE_p_dps__SymmetricKey, 0);
            break;
        case DPS_KEY_EC:
            argv[1] = SWIG_NewPointerObj(SWIG_as_voidptr(m_key), SWIGTYPE_p_dps__ECKey, 0);
            break;
        case DPS_KEY_EC_CERT:
            argv[1] = SWIG_NewPointerObj(SWIG_as_voidptr(m_key), SWIGTYPE_p_dps__CertKey, 0);
            break;
        }
        v8::MaybeLocal<v8::Value> ret = fn->Call(SWIGV8_CURRENT_CONTEXT(), SWIGV8_CURRENT_CONTEXT()->Global(),
                                                 argc, argv);
        int result = DPS_ERR_MISSING;
        if (!ret.IsEmpty()) {
            result = ret.ToLocalChecked()->IntegerValue();
        }
        *m_ret = result;
    }
    static DPS_Status Handler(DPS_KeyStoreRequest* request, const DPS_Key* key) {
        DPS_Status ret;
        sync_send(new EphemeralKeyCallback(request, key, &ret));
        return ret;
    }
};

class CACallback : public Callback {
public:
    DPS_KeyStoreRequest* m_request;
    DPS_Status* m_ret;
    CACallback(DPS_KeyStoreRequest* request, DPS_Status* ret)
        : m_request(request), m_ret(ret) { }
    void Call() {
        DPS_KeyStore* keyStore = DPS_KeyStoreHandle(m_request);
        KeyStoreFunctions* functions = (KeyStoreFunctions*)DPS_GetKeyStoreData(keyStore);
        v8::Local<v8::Function> fn = v8::Local<v8::Function>::New(v8::Isolate::GetCurrent(), functions->ca);
        int argc = 1;
        v8::Local<v8::Value> argv[argc];
        argv[0] = SWIG_NewPointerObj(SWIG_as_voidptr(m_request), SWIGTYPE_p__DPS_KeyStoreRequest, 0);
        v8::MaybeLocal<v8::Value> ret = fn->Call(SWIGV8_CURRENT_CONTEXT(), SWIGV8_CURRENT_CONTEXT()->Global(),
                                                 argc, argv);
        int result = DPS_ERR_MISSING;
        if (!ret.IsEmpty()) {
            result = ret.ToLocalChecked()->IntegerValue();
        }
        *m_ret = result;
    }
    static DPS_Status Handler(DPS_KeyStoreRequest* request) {
        DPS_Status ret;
        sync_send(new CACallback(request, &ret));
        return ret;
    }
};
%}

/*
 * Key callback wrapper
 */
%typemap(in) DPS_KeyAndIdHandler (v8::Local<v8::Function> fn) {
    if($input->IsNull()) {
        $1 = NULL;
    } else if ($input->IsFunction()) {
        fn = v8::Local<v8::Function>::Cast($input);
        $1 = KeyAndIdCallback::Handler;
    } else {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
}

%typemap(in) DPS_KeyHandler (v8::Local<v8::Function> fn) {
    if($input->IsNull()) {
        $1 = NULL;
    } else if ($input->IsFunction()) {
        fn = v8::Local<v8::Function>::Cast($input);
        $1 = KeyCallback::Handler;
    } else {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
}

%typemap(in) DPS_EphemeralKeyHandler (v8::Local<v8::Function> fn) {
    if($input->IsNull()) {
        $1 = NULL;
    } else if ($input->IsFunction()) {
        fn = v8::Local<v8::Function>::Cast($input);
        $1 = EphemeralKeyCallback::Handler;
    } else {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
}

%typemap(in) DPS_CAHandler (v8::Local<v8::Function> fn) {
    if($input->IsNull()) {
        $1 = NULL;
    } else if ($input->IsFunction()) {
        fn = v8::Local<v8::Function>::Cast($input);
        $1 = CACallback::Handler;
    } else {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
}

%typemap(out) DPS_KeyStore* {
    KeyStoreFunctions* functions = new KeyStoreFunctions();
    functions->keyAndId.Reset(v8::Isolate::GetCurrent(), fn1);
    functions->key.Reset(v8::Isolate::GetCurrent(), fn2);
    functions->ephemeralKey.Reset(v8::Isolate::GetCurrent(), fn3);
    functions->ca.Reset(v8::Isolate::GetCurrent(), fn4);
    DPS_SetKeyStoreData(result, functions);
    $result = SWIG_NewPointerObj(SWIG_as_voidptr(result), $1_descriptor, 0 | 0);
}

%{
void destroyKeyStore(DPS_KeyStore* keyStore)
{
    KeyStoreFunctions* functions = (KeyStoreFunctions*)DPS_GetKeyStoreData(keyStore);
    delete functions;
    DPS_DestroyKeyStore(keyStore);
}

DPS_Node* DPS_CreateNode(const char* separators, DPS_MemoryKeyStore* keyStore, const DPS_KeyId* keyId)
{
    return DPS_CreateNode(separators, DPS_MemoryKeyStoreHandle(keyStore), keyId);
}
%}

void destroyKeyStore(DPS_KeyStore* keyStore);

DPS_Node* DPS_CreateNode(const char* separators, DPS_MemoryKeyStore* keyStore, const DPS_KeyId* keyId);

%{
static v8::Handle<v8::Value> UUIDToString(DPS_UUID* uuid)
{
    v8::Handle<v8::Value> val;
    const char* uuidStr = DPS_UUIDToString(uuid);
    if (uuidStr) {
        val = SWIGV8_STRING_NEW2(uuidStr, strnlen(uuidStr, 2 * sizeof(DPS_UUID)));
    }
    return val;
}
%}

%typemap(out) DPS_UUID* {
    $result = UUIDToString($1);
}

%typemap(in) DPS_UUID* {
    DPS_UUID* uuid = NULL;

    v8::Handle<v8::Value> obj($input);

    if (obj->IsUint8Array()) {
        uuid = (DPS_UUID*)calloc(1, sizeof(DPS_UUID));
        if (!uuid) {
            SWIG_exception_fail(SWIG_ERROR, "no memory");
        }
        v8::Local<v8::Uint8Array> arr = v8::Local<v8::Uint8Array>::Cast($input);
        size_t len = arr->ByteLength();
        size_t off = arr->ByteOffset();
        uint8_t* data = (uint8_t*)arr->Buffer()->GetContents().Data();
        if (len <= 16) {
            memcpy(uuid->val, &data[off], len);
        } else {
            memcpy(uuid->val, &data[off], 16);
        }
    } else if (obj->IsArray()) {
        v8::Local<v8::Array> arr = v8::Local<v8::Array>::Cast($input);
        uint32_t n = arr->Length();
        uuid = (DPS_UUID*)calloc(1, sizeof(DPS_UUID));
        if (!uuid) {
            SWIG_exception_fail(SWIG_ERROR, "no memory");
        }
        uint32_t i;
        for (i = 0; (i < n) && (i < 16); ++i) {
            v8::Local<v8::Value> valRef;
            if (arr->Get(SWIGV8_CURRENT_CONTEXT(), i).ToLocal(&valRef)) {
                uuid->val[i] = valRef->Uint32Value();
            } else {
                free(uuid);
                SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
            }
        }
    } else if (!obj->IsNull()) {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }
    $1 = uuid;
}

%typemap(freearg) DPS_UUID* {
    free($1);
}

/*
 * Used in DPS_SetContentKey.
 */
%typemap(in) (const DPS_Key* key) {
    DPS_Key* k = NULL;
    void* argp = NULL;

    v8::Handle<v8::Value> obj($input);

    if (obj->IsUint8Array() || obj->IsArray()) {
        k = (DPS_Key*)calloc(1, sizeof(DPS_Key));
        if (!k) {
            SWIG_exception_fail(SWIG_ERROR, "no memory");
        }
        k->type = DPS_KEY_SYMMETRIC;
        if (!SWIG_IsOK(UnwrapBytes(obj, (uint8_t**)&k->symmetric.key, &k->symmetric.len))) {
            free(k);
            SWIG_exception_fail(SWIG_ERROR, "no memory");
        }
    } else if (SWIG_IsOK(SWIG_ConvertPtr(obj, &argp, SWIGTYPE_p_dps__SymmetricKey, 0 | 0))) {
        DPS_Key* key = (dps::SymmetricKey*)argp;
        k = (DPS_Key*)calloc(1, sizeof(DPS_Key));
        if (!k) {
            SWIG_exception_fail(SWIG_ERROR, "no memory");
        }
        k->type = DPS_KEY_SYMMETRIC;
        k->symmetric.len = key->symmetric.len;
        k->symmetric.key = (uint8_t*)malloc(k->symmetric.len);
        memcpy((uint8_t*)k->symmetric.key, key->symmetric.key, k->symmetric.len);
    } else if (SWIG_IsOK(SWIG_ConvertPtr(obj, &argp, SWIGTYPE_p_dps__ECKey, 0 | 0))) {
        DPS_Key* key = (dps::ECKey*)argp;
        k = (DPS_Key*)calloc(1, sizeof(DPS_Key));
        if (!k) {
            SWIG_exception_fail(SWIG_ERROR, "no memory");
        }
        memcpy(k, key, sizeof(*k));
    } else if (SWIG_IsOK(SWIG_ConvertPtr(obj, &argp, SWIGTYPE_p_dps__CertKey, 0 | 0))) {
        DPS_Key* key = (dps::CertKey*)argp;
        k = (DPS_Key*)calloc(1, sizeof(DPS_Key));
        if (!k) {
            SWIG_exception_fail(SWIG_ERROR, "no memory");
        }
        memcpy(k, key, sizeof(*k));
    } else if (!obj->IsNull()) {
        SWIG_exception_fail(SWIG_TypeError, "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
    }

    $1 = k;
}

%typemap(freearg) (const DPS_Key* key) {
    if ($1) {
        if (($1->type == DPS_KEY_SYMMETRIC) && $1->symmetric.key) {
            free((uint8_t*)$1->symmetric.key);
        }
        free($1);
    }
}

%extend dps::Key {
    const DPS_KeyType type;
}

%extend dps::SymmetricKey {
    const uint8_t* const key;
}

%ignore dps::ECKey::CoordinateSize;
%extend dps::ECKey {
    const DPS_ECCurve curve;
    const uint8_t* const x;
    const uint8_t* const y;
    const uint8_t* const d;
}

%extend dps::CertKey {
    const char* const cert;
    const char* const privateKey;
    const char* const password;
}

%{
const DPS_KeyType dps_Key_type_get(dps::Key* key) { return key->type; }

const uint8_t* const dps_SymmetricKey_key_get(dps::SymmetricKey* key) { return key->symmetric.key; }

DPS_ECCurve dps_ECKey_curve_get(dps::ECKey* key) { return key->ec.curve; }
const uint8_t* const dps_ECKey_x_get(dps::ECKey* key) { return key->ec.x; }
const uint8_t* const dps_ECKey_y_get(dps::ECKey* key) { return key->ec.y; }
const uint8_t* const dps_ECKey_d_get(dps::ECKey* key) { return key->ec.d; }

const char* const dps_CertKey_cert_get(dps::CertKey* key) { return key->cert.cert; }
const char* const dps_CertKey_privateKey_get(dps::CertKey* key) { return key->cert.privateKey; }
const char* const dps_CertKey_password_get(dps::CertKey* key) { return key->cert.password; }
%}

%typemap(in) dps::SymmetricKey* (size_t sz) {
    int res = SWIG_ConvertPtr(info.Holder(), (void**)&$1, $1_descriptor, 0 | 0);
    if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "1"" of type '" "$1_type""'");
    }
    sz = $1->symmetric.len;
}

%typemap(in) dps::ECKey* (size_t sz) {
    int res = SWIG_ConvertPtr(info.Holder(), (void**)&$1, $1_descriptor, 0 | 0);
    if (!SWIG_IsOK(res)) {
        SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "1"" of type '" "$1_type""'");
    }
    sz = $1->CoordinateSize();
}

%typemap(argout) dps::SymmetricKey*, dps::ECKey* {
    (void)sz$argnum;
}

%typemap(out) const uint8_t* const {
    $result = WrapBytes($1, sz1);
}

%typemap(in) (const char* key), (const char* password) {
    int res;
    char *buf = NULL;
    int alloc = SWIG_NEWOBJ;

    if (!$input->IsNull()) {
        res = SWIG_AsCharPtrAndSize($input, &buf, NULL, &alloc);
        if (!SWIG_IsOK(res)) {
            SWIG_exception_fail(SWIG_ArgError(res), "in method '" "$symname" "', argument " "$argnum"" of type '" "$1_type""'");
        }
    }

    $1 = buf;
}

%typemap(freearg) (const char* key), (const char* password) {
    delete[] $1;
}

/*
 * Disallow NULL for these pointer types
 * These appear to have no effect on the generated code
 */
%apply Pointer NONNULL { DPS_Node* };
%apply Pointer NONNULL { DPS_UUID* };
%apply Pointer NONNULL { DPS_Subscription* };
%apply Pointer NONNULL { DPS_Publication* };
%apply Pointer NONNULL { DPS_PublicationAck* };
%apply Pointer NONNULL { DPS_NodeAddress* };

%include <dps/dps.h>
%include <dps/dbg.h>
%include <dps/err.h>
%include "dps.hh"

/*
 * Module initialization
 */
%init %{
    /* Must be called during module initialization to enable DPS callbacks */
    node_thread = uv_thread_self();
    uv_async_init(uv_default_loop(), &async, async_cb);
    DPS_Debug = 0;
%}
